{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SpuckJs Welcome to the official SpuckJs documentation SpuckJs is a new JavaScript Library which lets you create UI Elements , just like any other framework. Approach Here, you create an instance (object) of the class Spuck . The library converts these pure js objects into DOM elements. Features You can pass classes and attributes , bind events and do all sorts of basic operations on your objects. Moreover, you can define states and effects for each new object. You can also share states with parent, partner or child elements (doesn't matter) . About This is an open source project, which can be found on Github . It is licensed under the MIT License . It is developed by Rakshit , social handles: Github \u2800 Instagram \u2800 Twitter \u2800 LinkedIn","title":"Home"},{"location":"#spuckjs","text":"Welcome to the official SpuckJs documentation SpuckJs is a new JavaScript Library which lets you create UI Elements , just like any other framework.","title":"SpuckJs"},{"location":"#approach","text":"Here, you create an instance (object) of the class Spuck . The library converts these pure js objects into DOM elements.","title":"Approach"},{"location":"#features","text":"You can pass classes and attributes , bind events and do all sorts of basic operations on your objects. Moreover, you can define states and effects for each new object. You can also share states with parent, partner or child elements (doesn't matter) .","title":"Features"},{"location":"#about","text":"This is an open source project, which can be found on Github . It is licensed under the MIT License . It is developed by Rakshit , social handles: Github \u2800 Instagram \u2800 Twitter \u2800 LinkedIn","title":"About"},{"location":"EffectManagement/","text":"Effects Effects are functions that can run on every or particular renders of an element. We give a dependency array to an effects, these can be states / pseudo-states or partial dependencies of the element. On every render , if these dependencies change , the effect will run . Partial dependencies are, when you want the effect to run on every or first render of the element. Syntax We use the $effect method to create an effect. const Element = new Spuck ({ ... }). render (); const setState = Element . $state ( 'state' , 0 ); Element . prop = { text : '$-state' } Element . events = { click : () => setState ( p => p + 1 ) } Element . $effect (() => { console . log ( 'Effect ran' ); }, [ '$-state' ]) const Child = new Spuck ({ ... }). render (); Element . init . pseudoChildren = [ Child ]; Element . render ( 're' ); Child . $effect (() => { console . log ( 'Child Effect ran' ); }, [ '$$-state' ]) Element . make ( 're' ) Child . make ( 're' ) Working In the above example, we created an element with a state and a click event. Whenever the element is clicked, the state is updated, and the element re-renders. When the re-render is almost done , library checks if any dependency of any effect has changed . If it has, the effect runs. In case of Child , it is a pseudo-child of Element , and its effect depends on its pseudo-state , $$-state . NOTE: An effect will always run on its first render . NOTE: There can be multiple dependencies of an effect, if any changes , the effect runs . Example We'll create a UI with a heading element that will show product of two numbers . The two numbers will be managed by two states . We will be able to increment both numbers by clicking on buttons. The product will be managed by an effect . const H1 = new Spuck ({ type : 'h1' , parent : '#app' , class : 'head' }). render (); const setCount = H1 . $state ( 'count' , 0 ); const setMultiplier = H1 . $state ( 'by' , 1 ); Now to multiply we will create a separate function. const product = () => H1 . getState ( 'count' ) * H1 . getState ( 'by' ); H1 . prop = { text : `Product = ${ product } ` , css : { color : 'red' } // maybe a bit of css }; You see we are using getState , because product will be managed by an effect => that line of code will run again, so the value of product will be updated. Now we will create an effect on the H1 element that will depend on both count and by states. H1 . $effect (() => { H1 . prop . text = `$-count x $-by = ${ product () } ` ; H1 . render ( 're' ); }, [ '$-count' , '$-by' ]); H1 . make ( 're' ); So whenever one of the states changes, the effect will run and update the H1 element's text . We are done with the Heading . Now we will create two buttons to increment the count and by states. As buttons will have similar structure , leaving few traits to be different, we will create button as function Button ({ class : 'count' , text : 'Counter' , update : setCount }); Button ({ class : 'by' , text : 'Multiplier' , update : setMultiplier }); function Button ( properties ) { const Button = new Spuck ({ type : 'button' , parent : '#app' , class : properties . class }); Button . prop = { text : properties . text , css : { cursor : 'pointer' } }; Button . events = { click : () => properties . update ( prevCount => prevCount + 1 ) }; Button . make (); }; Partial Dependencies These dependencies let you run your effects independent of any state / pseudo-state . There are two types of partial dependencies: ['f'] This runs the effect only on the first render of the element. ['e'] This runs the effect on every render of the element. AnyElement . $effect (() => f (), [ 'f' ]); // on first render AnyElement . $effect (() => e (), [ 'e' ]); // on every render","title":"Effects"},{"location":"EffectManagement/#effects","text":"Effects are functions that can run on every or particular renders of an element. We give a dependency array to an effects, these can be states / pseudo-states or partial dependencies of the element. On every render , if these dependencies change , the effect will run . Partial dependencies are, when you want the effect to run on every or first render of the element.","title":"Effects"},{"location":"EffectManagement/#syntax","text":"We use the $effect method to create an effect. const Element = new Spuck ({ ... }). render (); const setState = Element . $state ( 'state' , 0 ); Element . prop = { text : '$-state' } Element . events = { click : () => setState ( p => p + 1 ) } Element . $effect (() => { console . log ( 'Effect ran' ); }, [ '$-state' ]) const Child = new Spuck ({ ... }). render (); Element . init . pseudoChildren = [ Child ]; Element . render ( 're' ); Child . $effect (() => { console . log ( 'Child Effect ran' ); }, [ '$$-state' ]) Element . make ( 're' ) Child . make ( 're' )","title":"Syntax"},{"location":"EffectManagement/#working","text":"In the above example, we created an element with a state and a click event. Whenever the element is clicked, the state is updated, and the element re-renders. When the re-render is almost done , library checks if any dependency of any effect has changed . If it has, the effect runs. In case of Child , it is a pseudo-child of Element , and its effect depends on its pseudo-state , $$-state . NOTE: An effect will always run on its first render . NOTE: There can be multiple dependencies of an effect, if any changes , the effect runs .","title":"Working"},{"location":"EffectManagement/#example","text":"We'll create a UI with a heading element that will show product of two numbers . The two numbers will be managed by two states . We will be able to increment both numbers by clicking on buttons. The product will be managed by an effect . const H1 = new Spuck ({ type : 'h1' , parent : '#app' , class : 'head' }). render (); const setCount = H1 . $state ( 'count' , 0 ); const setMultiplier = H1 . $state ( 'by' , 1 ); Now to multiply we will create a separate function. const product = () => H1 . getState ( 'count' ) * H1 . getState ( 'by' ); H1 . prop = { text : `Product = ${ product } ` , css : { color : 'red' } // maybe a bit of css }; You see we are using getState , because product will be managed by an effect => that line of code will run again, so the value of product will be updated. Now we will create an effect on the H1 element that will depend on both count and by states. H1 . $effect (() => { H1 . prop . text = `$-count x $-by = ${ product () } ` ; H1 . render ( 're' ); }, [ '$-count' , '$-by' ]); H1 . make ( 're' ); So whenever one of the states changes, the effect will run and update the H1 element's text . We are done with the Heading . Now we will create two buttons to increment the count and by states. As buttons will have similar structure , leaving few traits to be different, we will create button as function Button ({ class : 'count' , text : 'Counter' , update : setCount }); Button ({ class : 'by' , text : 'Multiplier' , update : setMultiplier }); function Button ( properties ) { const Button = new Spuck ({ type : 'button' , parent : '#app' , class : properties . class }); Button . prop = { text : properties . text , css : { cursor : 'pointer' } }; Button . events = { click : () => properties . update ( prevCount => prevCount + 1 ) }; Button . make (); };","title":"Example"},{"location":"EffectManagement/#partial-dependencies","text":"These dependencies let you run your effects independent of any state / pseudo-state . There are two types of partial dependencies: ['f'] This runs the effect only on the first render of the element. ['e'] This runs the effect on every render of the element. AnyElement . $effect (() => f (), [ 'f' ]); // on first render AnyElement . $effect (() => e (), [ 'e' ]); // on every render","title":"Partial Dependencies"},{"location":"GettingStarted/","text":"Getting Started This section will show you how to get started with SpuckJs. new Spuck() We know that every object of class Spuck is a virtual element that has to be put in the DOM . const Element = new Spuck (); If we console log this Element we can see different properties and methods. Spuck = { init : undefined prop : undefined events : undefined attr : undefined _pseudoState : {} _state : {} # _CSP : \"$$-\" # _SP : \"$-\" # _alterState : # _alterState ( _finVal , _name ) # _deps : Object # _effects : Object # _getStateName : \u0192 # _getStateName ( _stateName ) # _partialEffects : Object } First 4 properties are the important ones for basic operations, others are managed by the library init : This will be an object , and will define type, parent, class and id (this is necessary) . prop : ... object and will define text, value and css of the element. events : ... object and will define events . attr : ... object and will define attributes . Creating a Heading element. const Heading = new Spuck (); Heading . init = { type : \"h1\" , parent : \"#app\" , // a div defined in the html file class : \"heading\" , id : \"heading\" }; Doing the initalizing part in one line is handy. const Heading = new Spuck ({ type : 'h1' , parent : '#app' , class : 'heading' , id : 'heading' }); Heading . prop = { text : 'Hello Spuck' }; Here we defined the text of element, in prop property. This element will be put in the DOM , but it is not yet ready to be mounted . render() Our Heading element is just a virtual element that has to be put in the DOM . To convert it into a real DOM element we use render method. Heading . render (); This method adds bunch of properties defined into the physical element . NOTE: render does not mount the element, it just creates or updates an element with some properties. When you render an element more than once you pass a parameter to the method, i.e., 're' AnyElement . render ( 're' ) render with no parameter creates a new element with some properties, while render('re') updates the element with some properties. Late Note render does mount an element in a case , we'll look at it later . DOM Methods mount() mount is a method that puts an element in the DOM . unMount() unMount is a method that removes an element from the DOM . isMount() isMount is a method that checks if an element is mounted or not . make() make just combines render and mount methods. It also accepts a parameter to be re , when element is already rendered . It just passes the parameter to the render method. So in our case of Heading, we should probably use make , as it is a very simple element. You don't have to render it if you use make . ... Heading . make (); Now the element is in the DOM. Heading at once const Heading = new Spuck ({ type : 'h1' , parent : '#app' , class : 'heading' , id : 'heading' }); Heading . prop = { text : 'Hello Spuck' }; Heading . make ();","title":"Getting Started"},{"location":"GettingStarted/#getting-started","text":"This section will show you how to get started with SpuckJs.","title":"Getting Started"},{"location":"GettingStarted/#new-spuck","text":"We know that every object of class Spuck is a virtual element that has to be put in the DOM . const Element = new Spuck (); If we console log this Element we can see different properties and methods. Spuck = { init : undefined prop : undefined events : undefined attr : undefined _pseudoState : {} _state : {} # _CSP : \"$$-\" # _SP : \"$-\" # _alterState : # _alterState ( _finVal , _name ) # _deps : Object # _effects : Object # _getStateName : \u0192 # _getStateName ( _stateName ) # _partialEffects : Object } First 4 properties are the important ones for basic operations, others are managed by the library init : This will be an object , and will define type, parent, class and id (this is necessary) . prop : ... object and will define text, value and css of the element. events : ... object and will define events . attr : ... object and will define attributes . Creating a Heading element. const Heading = new Spuck (); Heading . init = { type : \"h1\" , parent : \"#app\" , // a div defined in the html file class : \"heading\" , id : \"heading\" }; Doing the initalizing part in one line is handy. const Heading = new Spuck ({ type : 'h1' , parent : '#app' , class : 'heading' , id : 'heading' }); Heading . prop = { text : 'Hello Spuck' }; Here we defined the text of element, in prop property. This element will be put in the DOM , but it is not yet ready to be mounted .","title":"new Spuck()"},{"location":"GettingStarted/#render","text":"Our Heading element is just a virtual element that has to be put in the DOM . To convert it into a real DOM element we use render method. Heading . render (); This method adds bunch of properties defined into the physical element . NOTE: render does not mount the element, it just creates or updates an element with some properties. When you render an element more than once you pass a parameter to the method, i.e., 're' AnyElement . render ( 're' ) render with no parameter creates a new element with some properties, while render('re') updates the element with some properties.","title":"render()"},{"location":"GettingStarted/#late-note","text":"render does mount an element in a case , we'll look at it later .","title":"Late Note"},{"location":"GettingStarted/#dom-methods","text":"","title":"DOM Methods"},{"location":"GettingStarted/#mount","text":"mount is a method that puts an element in the DOM .","title":"mount()"},{"location":"GettingStarted/#unmount","text":"unMount is a method that removes an element from the DOM .","title":"unMount()"},{"location":"GettingStarted/#ismount","text":"isMount is a method that checks if an element is mounted or not .","title":"isMount()"},{"location":"GettingStarted/#make","text":"make just combines render and mount methods. It also accepts a parameter to be re , when element is already rendered . It just passes the parameter to the render method. So in our case of Heading, we should probably use make , as it is a very simple element. You don't have to render it if you use make . ... Heading . make (); Now the element is in the DOM.","title":"make()"},{"location":"GettingStarted/#heading-at-once","text":"const Heading = new Spuck ({ type : 'h1' , parent : '#app' , class : 'heading' , id : 'heading' }); Heading . prop = { text : 'Hello Spuck' }; Heading . make ();","title":"Heading at once"},{"location":"InbuiltFeatures/","text":"Inbuilt Features Features like conditional rendering , iterative rendering etc. These are new features, and still in development. NOTE: Only conditional rendering is implemented till now . Conditional Rendering You can use this feature to mount an element only when some condition is satisfied. When the element re-renders, it checks if the condition is met or not. If it is true, it mounts the element, otherwise it unmounts it. Here on every re-render , render method checks if the condition is met or not, and it itself mounts or unmounts the element. This was the case we were talking about earlier , where render method also mounts or unmounts the element. There can be two cases: Case 1: When condition for rendering is external to the element. Case 2: When condition for rendering is internal to the element. Syntax AnyElement . renderIf ( condition : function : boolean ); Condition is a function which returns a boolean value. This conditions get evaluated on every re-render . Example These two examples will cover both cases. Case 1: External Condition First we'll create a basic count element. const Count = new Spuck ({ type : 'span' , parent : '#app' }). render (); const setCount = Count . $state ( 'count' , 0 ); Count . prop = { text : '$-count' }; Count . make ( 're' ); Let's create the condition function. const oddCondition = () => Count . getState ( 'count' ) % 2 !== 0 ; // condition for odd element const evenCondition = () => Count . getState ( 'count' ) % 2 === 0 ; // condition for even element const Div = new Spuck ({ type : 'div' , parent : '#app' , class : 'parent' }). make (); The Div element will contain the odd/even elements based on the condition. Now we will show two elements, depending on odd/even of the count. const EvenElement = new Spuck ({ type : 'h3' , parent : '.parent' , id : 'even' }); // using pseudo-state, explained after the codeblock EvenElement . prop = { text : '$$-count Even' }; EvenElement . renderIf (() => evenCondition ()); const OddElement = new Spuck ({ type : 'h2' , parent : '.parent' , id : 'odd' }); OddElement . prop = { text : '$$-count Odd' }; OddElement . renderIf (() => oddCondition ()); Note that the conditions are external to the elements. Now we will declare these two elements as pseudo-children of the Count element. So when the Count element will re-render , it will also make the conditional elements to re-render. Then the elements will check again, wheather to mount or not , because the state of Count would have been changed and the conditions depend on the state. So this will cause the conditions to change too. Count . init . pseudoChildren = [ EvenElement , OddElement ]; Count . render ( 're' ); EvenElement . make ( 're' ); OddElement . make ( 're' ); Now we will create a button to increment the count. const Button = new Spuck ({ type : 'button' , parent : '#app' , id : 'button' }); Button . prop = { text : 'Click Me' }; Button . events = { click : () => setCount ( a => a + 1 ) }; Button . make (); When the count state will be an even number , only the EvenElement will be on the DOM and vice-versa. On button click, count state is changing which is causing the two elements to check their conditions again. Case 2: Internal Condition We will again create a count element and its condition would depend on its own state . Though the state will be updated by another element . const ShowCount = new Spuck ({ type : 'div' , parent : '#app' , id : 'show-count' }). render (); const setShowCount = ShowCount . $state ( 'showCount' , 0 ); ShowCount . prop = { text : '$-showCount' } Condition: State should be an even number. const showCountCondition = () => ShowCount . getState ( 'showCount' ) % 2 === 0 ; ShowCount . renderIf (() => showCountCondition ()); Now a very normal button const Click = new Spuck ({ type : 'button' , parent : '#app' , class : 'click' }). render (); Click . props = { text : 'Click Me' }; Click . events = { click : () => setShowCount ( a => a + 1 ) }; Click . make ( 're' ); ShowCount . make ( 're' ); // we are making it after, so that it appears after the button in the DOM When button is clicked, state of ShowCount will change, and the condition will be checked again. To be continued... maybe .","title":"Inbuilt Features"},{"location":"InbuiltFeatures/#inbuilt-features","text":"Features like conditional rendering , iterative rendering etc. These are new features, and still in development. NOTE: Only conditional rendering is implemented till now .","title":"Inbuilt Features"},{"location":"InbuiltFeatures/#conditional-rendering","text":"You can use this feature to mount an element only when some condition is satisfied. When the element re-renders, it checks if the condition is met or not. If it is true, it mounts the element, otherwise it unmounts it. Here on every re-render , render method checks if the condition is met or not, and it itself mounts or unmounts the element. This was the case we were talking about earlier , where render method also mounts or unmounts the element. There can be two cases: Case 1: When condition for rendering is external to the element. Case 2: When condition for rendering is internal to the element.","title":"Conditional Rendering"},{"location":"InbuiltFeatures/#syntax","text":"AnyElement . renderIf ( condition : function : boolean ); Condition is a function which returns a boolean value. This conditions get evaluated on every re-render .","title":"Syntax"},{"location":"InbuiltFeatures/#example","text":"These two examples will cover both cases.","title":"Example"},{"location":"InbuiltFeatures/#case-1-external-condition","text":"First we'll create a basic count element. const Count = new Spuck ({ type : 'span' , parent : '#app' }). render (); const setCount = Count . $state ( 'count' , 0 ); Count . prop = { text : '$-count' }; Count . make ( 're' ); Let's create the condition function. const oddCondition = () => Count . getState ( 'count' ) % 2 !== 0 ; // condition for odd element const evenCondition = () => Count . getState ( 'count' ) % 2 === 0 ; // condition for even element const Div = new Spuck ({ type : 'div' , parent : '#app' , class : 'parent' }). make (); The Div element will contain the odd/even elements based on the condition. Now we will show two elements, depending on odd/even of the count. const EvenElement = new Spuck ({ type : 'h3' , parent : '.parent' , id : 'even' }); // using pseudo-state, explained after the codeblock EvenElement . prop = { text : '$$-count Even' }; EvenElement . renderIf (() => evenCondition ()); const OddElement = new Spuck ({ type : 'h2' , parent : '.parent' , id : 'odd' }); OddElement . prop = { text : '$$-count Odd' }; OddElement . renderIf (() => oddCondition ()); Note that the conditions are external to the elements. Now we will declare these two elements as pseudo-children of the Count element. So when the Count element will re-render , it will also make the conditional elements to re-render. Then the elements will check again, wheather to mount or not , because the state of Count would have been changed and the conditions depend on the state. So this will cause the conditions to change too. Count . init . pseudoChildren = [ EvenElement , OddElement ]; Count . render ( 're' ); EvenElement . make ( 're' ); OddElement . make ( 're' ); Now we will create a button to increment the count. const Button = new Spuck ({ type : 'button' , parent : '#app' , id : 'button' }); Button . prop = { text : 'Click Me' }; Button . events = { click : () => setCount ( a => a + 1 ) }; Button . make (); When the count state will be an even number , only the EvenElement will be on the DOM and vice-versa. On button click, count state is changing which is causing the two elements to check their conditions again.","title":"Case 1: External Condition"},{"location":"InbuiltFeatures/#case-2-internal-condition","text":"We will again create a count element and its condition would depend on its own state . Though the state will be updated by another element . const ShowCount = new Spuck ({ type : 'div' , parent : '#app' , id : 'show-count' }). render (); const setShowCount = ShowCount . $state ( 'showCount' , 0 ); ShowCount . prop = { text : '$-showCount' } Condition: State should be an even number. const showCountCondition = () => ShowCount . getState ( 'showCount' ) % 2 === 0 ; ShowCount . renderIf (() => showCountCondition ()); Now a very normal button const Click = new Spuck ({ type : 'button' , parent : '#app' , class : 'click' }). render (); Click . props = { text : 'Click Me' }; Click . events = { click : () => setShowCount ( a => a + 1 ) }; Click . make ( 're' ); ShowCount . make ( 're' ); // we are making it after, so that it appears after the button in the DOM When button is clicked, state of ShowCount will change, and the condition will be checked again.","title":"Case 2: Internal Condition"},{"location":"InbuiltFeatures/#to-be-continued","text":"maybe .","title":"To be continued..."},{"location":"SettingUp/","text":"Setting Up This section will show you how to setup your project. Script Tag You can easily get started by adding this script tag to your html file. < script src = 'https://cdn.jsdelivr.net/gh/spuckhafte/SpuckJs@1.0.1/Spuck.js' ></ script > < script src = \"index.js\" defer ></ script > Make sure to defer your main script, so that it loads after the library. NPX You can use the npx command to generate a basic Counter project template. npx create-spuck-template You need node js in your system to use this command.","title":"Setting Up"},{"location":"SettingUp/#setting-up","text":"This section will show you how to setup your project.","title":"Setting Up"},{"location":"SettingUp/#script-tag","text":"You can easily get started by adding this script tag to your html file. < script src = 'https://cdn.jsdelivr.net/gh/spuckhafte/SpuckJs@1.0.1/Spuck.js' ></ script > < script src = \"index.js\" defer ></ script > Make sure to defer your main script, so that it loads after the library.","title":"Script Tag"},{"location":"SettingUp/#npx","text":"You can use the npx command to generate a basic Counter project template. npx create-spuck-template You need node js in your system to use this command.","title":"NPX"},{"location":"StateManagement/","text":"State Management States are some internal values maintained by an element. These are important because if these values change , the element gets re-rendered . You can refer to them in code, like in innerHTML , css or any other property of the element. On change , the element automatically updates their reference in the code. $state Method In SpuckJs, we use the state using $state method. $state method returns a function to update that state. NOTE: State can only be managed in a rendered element. Let's see how it works. /* Lets create a new display element. Render it while initializing because State can only be managed in a rendered element. */ const Display = new Spuck ({ type : 'h3' , parent : '#app' , id : 'dis' }). render (); const setCount = Display . $state ( 'count' , 0 ); First Parameter : name of state Second Parameter : initial value of state Now to refer this state in the code, there are two ways : .getState method Element . prop = { text : Element . getState ( stateName ) } When you refer to the state value using this method, it will not update the reference in the code when state changes. It can only update if the line of code where this method is mentioned runs again . That is, if used in a loop , bind to an event or used in an effect . In all these cases, the state value will be updated when the line of code runs again. $- reference If you truly want to see the state reference update in the code, you use $- reference. Element . prop = { text : '$-count' }; This will update the reference in the code when state changes. Syntax : $-stateName NOTE : $- can only be used in internal properties of the element. You can't do operations using this, { text: '$-count + 1' } . Back to the example. Display . prop = { text : 'Count is $-count' }; Display . make ( 're' ); we are done with Display element, so we make it. We'll update the count using another element : Button setState function If you want to update any state of the element, you use the method returned by $state method. By convention, we call this method set{StateName} When you call it, it automatically re-renders the element after updating the state. We pass a new value of state to this method. There can be two ways for it: Direct Functional Direct way In this case, we pass the latest state value directly as parameter. // suppose we want to update color of the element setState ( 'red' ); // suppose we want to increment any \"Click State\" by 1 setClick ( Element . getState ( 'click' ) + 1 ); // see how we \"used\" the \"getState\" method Functional way Here, we pass state value with respect to the previous state value as parameter using a functional approach We call a function as parameter, whose argument is the previous state value. Then we return a new value for state by manipulating previous one. // suppose we want to update the state to double the previous value setState ( function ( previousState ) { return previousState * 2 ; }); // this can be simplified using arrow function setState ( prevState => prevState * 2 ); // see how we \"ignored\" the \"getState\" method \u2800 Back to our Display example, we can use setState to update count on a button click /* Defining a button, we don't necessarily need to render it at this point cause there is no state of the \"Button\" to manage. */ const Button = new Spuck ({ type : 'button' , parent : '#app' , id : 'btn' }); Button . prop = { text : 'Update Count' }; Button . events = { // on click, update count using functional approach click : () => setCount ( prevCount => prevCount + 1 ) }; Button . make (); Display at once: const Display = new Spuck ({ type : 'h3' , parent : '#app' , id : 'dis' }). render (); const setCount = Display . $state ( 'count' , 0 ); Display . prop = { text : 'Count is $-count' }; Display . make ( 're' ); const Button = new Spuck ({ type : 'button' , parent : '#app' , id : 'btn' }); Button . prop = { text : 'Update Count' }; Button . events = { click : () => setCount ( prevCount => prevCount + 1 ) }; Button . make (); State Sharing In SpuckJs you can easily share states to other elements. You can share states to siblings , parent , children or any other elements , it does not matter . Pseudo Children/States SpuckJs does it by using a concept called pseudo-Children . If you want to share state of Element 1 with Element 2 , you can do it by making \"Element 2\" a pseudo-Child of \"Element 1\" . const Element1 = new Spuck ({ ... }). render (); const Element2 = new Spuck ({ ... }). render (); Element1 . init . pseudoChildren = [ Element2 ]; Element1 . render ( 're' ); pseudoChildren is a property of init object of the element. It is an array , and can hold multiple elements . Now all the states of Element 1 are accessible to Element 2 as pseudo-states . NOTE : When an element renders, all its pseudo-children are also rendered. Referencing them Just like normal states, you can refer to pseudo-states either using: .getPseudoState method, or $$- reference NOTE: $- : states and $$- : pseudo-states Extending \"Display\" Example Suppose there is one more element, say Display2 , below the Button , which shows the count of the Display element. We will make Display2 a pseudo-child of Display , to access the count state. const Display2 = new Spuck ({ type : 'h3' , parent : '#app' , id : 'dis2' }); Display1 . init . pseudoChildren = [ Display2 ]; Display1 . render ( 're' ); Now we can access the count state of Display from Display2 as pseudo-state . Display2 . prop = { text : 'Display count is $$-count' }; Display2 . make ( 're' ); Looking at the Object If we console log the Display element now, we can see how are properties managed. You can see states are stored in _state property of the element. Each state is an array => [value, setter] Display : pseudo-child : Display2 It contains the whole virtual element of Display2 in the pseudoChildren array. \u2800 Looking at Display2 It does not differ much, but instead of _state property, its _pseudoState property is defined, which has the same structure as _state . You can see the el property of both elements, that is the physical element stored within the virtual element . If we console log Display.el , we can see the HTML element: Its there if you ever have to interact with the browser api , you can use it.","title":"State Management"},{"location":"StateManagement/#state-management","text":"States are some internal values maintained by an element. These are important because if these values change , the element gets re-rendered . You can refer to them in code, like in innerHTML , css or any other property of the element. On change , the element automatically updates their reference in the code.","title":"State Management"},{"location":"StateManagement/#state-method","text":"In SpuckJs, we use the state using $state method. $state method returns a function to update that state. NOTE: State can only be managed in a rendered element. Let's see how it works. /* Lets create a new display element. Render it while initializing because State can only be managed in a rendered element. */ const Display = new Spuck ({ type : 'h3' , parent : '#app' , id : 'dis' }). render (); const setCount = Display . $state ( 'count' , 0 ); First Parameter : name of state Second Parameter : initial value of state Now to refer this state in the code, there are two ways :","title":"$state Method"},{"location":"StateManagement/#getstate-method","text":"Element . prop = { text : Element . getState ( stateName ) } When you refer to the state value using this method, it will not update the reference in the code when state changes. It can only update if the line of code where this method is mentioned runs again . That is, if used in a loop , bind to an event or used in an effect . In all these cases, the state value will be updated when the line of code runs again.","title":".getState method"},{"location":"StateManagement/#-reference","text":"If you truly want to see the state reference update in the code, you use $- reference. Element . prop = { text : '$-count' }; This will update the reference in the code when state changes. Syntax : $-stateName NOTE : $- can only be used in internal properties of the element. You can't do operations using this, { text: '$-count + 1' } . Back to the example. Display . prop = { text : 'Count is $-count' }; Display . make ( 're' ); we are done with Display element, so we make it. We'll update the count using another element : Button","title":"$- reference"},{"location":"StateManagement/#setstate-function","text":"If you want to update any state of the element, you use the method returned by $state method. By convention, we call this method set{StateName} When you call it, it automatically re-renders the element after updating the state. We pass a new value of state to this method. There can be two ways for it: Direct Functional","title":"setState function"},{"location":"StateManagement/#direct-way","text":"In this case, we pass the latest state value directly as parameter. // suppose we want to update color of the element setState ( 'red' ); // suppose we want to increment any \"Click State\" by 1 setClick ( Element . getState ( 'click' ) + 1 ); // see how we \"used\" the \"getState\" method","title":"Direct way"},{"location":"StateManagement/#functional-way","text":"Here, we pass state value with respect to the previous state value as parameter using a functional approach We call a function as parameter, whose argument is the previous state value. Then we return a new value for state by manipulating previous one. // suppose we want to update the state to double the previous value setState ( function ( previousState ) { return previousState * 2 ; }); // this can be simplified using arrow function setState ( prevState => prevState * 2 ); // see how we \"ignored\" the \"getState\" method \u2800 Back to our Display example, we can use setState to update count on a button click /* Defining a button, we don't necessarily need to render it at this point cause there is no state of the \"Button\" to manage. */ const Button = new Spuck ({ type : 'button' , parent : '#app' , id : 'btn' }); Button . prop = { text : 'Update Count' }; Button . events = { // on click, update count using functional approach click : () => setCount ( prevCount => prevCount + 1 ) }; Button . make ();","title":"Functional way"},{"location":"StateManagement/#display-at-once","text":"const Display = new Spuck ({ type : 'h3' , parent : '#app' , id : 'dis' }). render (); const setCount = Display . $state ( 'count' , 0 ); Display . prop = { text : 'Count is $-count' }; Display . make ( 're' ); const Button = new Spuck ({ type : 'button' , parent : '#app' , id : 'btn' }); Button . prop = { text : 'Update Count' }; Button . events = { click : () => setCount ( prevCount => prevCount + 1 ) }; Button . make ();","title":"Display at once:"},{"location":"StateManagement/#state-sharing","text":"In SpuckJs you can easily share states to other elements. You can share states to siblings , parent , children or any other elements , it does not matter .","title":"State Sharing"},{"location":"StateManagement/#pseudo-childrenstates","text":"SpuckJs does it by using a concept called pseudo-Children . If you want to share state of Element 1 with Element 2 , you can do it by making \"Element 2\" a pseudo-Child of \"Element 1\" . const Element1 = new Spuck ({ ... }). render (); const Element2 = new Spuck ({ ... }). render (); Element1 . init . pseudoChildren = [ Element2 ]; Element1 . render ( 're' ); pseudoChildren is a property of init object of the element. It is an array , and can hold multiple elements . Now all the states of Element 1 are accessible to Element 2 as pseudo-states . NOTE : When an element renders, all its pseudo-children are also rendered.","title":"Pseudo Children/States"},{"location":"StateManagement/#referencing-them","text":"Just like normal states, you can refer to pseudo-states either using: .getPseudoState method, or $$- reference NOTE: $- : states and $$- : pseudo-states","title":"Referencing them"},{"location":"StateManagement/#extending-display-example","text":"Suppose there is one more element, say Display2 , below the Button , which shows the count of the Display element. We will make Display2 a pseudo-child of Display , to access the count state. const Display2 = new Spuck ({ type : 'h3' , parent : '#app' , id : 'dis2' }); Display1 . init . pseudoChildren = [ Display2 ]; Display1 . render ( 're' ); Now we can access the count state of Display from Display2 as pseudo-state . Display2 . prop = { text : 'Display count is $$-count' }; Display2 . make ( 're' );","title":"Extending \"Display\" Example"},{"location":"StateManagement/#looking-at-the-object","text":"If we console log the Display element now, we can see how are properties managed. You can see states are stored in _state property of the element. Each state is an array => [value, setter] Display : pseudo-child : Display2 It contains the whole virtual element of Display2 in the pseudoChildren array. \u2800 Looking at Display2 It does not differ much, but instead of _state property, its _pseudoState property is defined, which has the same structure as _state . You can see the el property of both elements, that is the physical element stored within the virtual element . If we console log Display.el , we can see the HTML element: Its there if you ever have to interact with the browser api , you can use it.","title":"Looking at the Object"}]}